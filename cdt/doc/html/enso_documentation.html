
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>enso documentation</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-01-24"><meta name="DC.source" content="enso_documentation.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1><tt>enso</tt> documentation</h1><!--introduction--><p><tt>enso</tt> computes a version of the Nino 3.4 SST index.</p><p><a href="CDT_Contents.html">Back to Climate Data Tools Contents</a></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Example 1: Automatic Nino 3.4</a></li><li><a href="#5">Plot it up real nice</a></li><li><a href="#6">A bit of context</a></li><li><a href="#9">Example 2: A manual approach</a></li><li><a href="#10">Defining the Nino region</a></li><li><a href="#18">Example 3: Recreating Trenberth 1997</a></li><li><a href="#20">References</a></li><li><a href="#21">Author Info</a></li></ul></div><h2 id="1">Syntax</h2><pre>idx = enso(sst,t)
idx = enso(sst,t,lat,lon)
idx = enso(sst,t,lat,lon,'region',NinoRegion)
idx = enso(sst,t,mask)
idx = enso(...,'smoothing',months)</pre><h2 id="2">Description</h2><p><tt>idx = enso(sst,t)</tt> calculates El Nino Southern Oscillation index from a time series of sea surface temperatures sst and their corresponding times <tt>t</tt>. sst can be a vector of sea surface temperatures that have been averaged over a region of interest, or sst can be a 3D matrix whose third dimension correponds to times <tt>t</tt>. If sst is a 3D matrix, a time series is automatically generated by averaging all the grid cells in sst for each time step.</p><p><tt>idx = enso(sst,t,lat,lon)</tt> calculates the Nino 3.4 index for 3D <tt>sst</tt> time series and corresponding grid coordinates <tt>lat,lon</tt>. Using this syntax, grid cells within the Nino 3.4 region are automatically determined and the Nino index is calculated from the area-averaged time series of ssts within that region.</p><p><tt>idx = enso(sst,t,lat,lon,'region',NinoRegion)</tt> allows any of the following Nino regions, entered as string (in 'single quotes')</p><div><ul><li><tt>'1+2'</tt></li><li><tt>'3'</tt></li><li><tt>'3.4'</tt> (default when lat and lon are specified)</li><li><tt>'4'</tt></li><li><tt>'ONI'</tt></li></ul></div><p><tt>idx = enso(sst,t,mask)</tt> calculates the sst index using the unweighted mean of sst grid cells corresponding to true values in a 2D logical <tt>mask</tt>.</p><p><tt>idx = enso(...,'smoothing',months)</tt> defines the moving average window in months. Default value is <tt>5</tt>, following Trenberth 1997. The only exception is for the ONI region, which has a smoothing window of <tt>3</tt> months. To turn off averaging, set <tt>'smoothing',false</tt>.</p><h2 id="3">Example 1: Automatic Nino 3.4</h2><p>For this example, calculate the Nino 3.4 index using the monthly pacific_sst.mat dataset that comes with CDT. Start by loading the data, and then the <tt>enso</tt> function will want to know exactly what geo coordinates correspond to each grid cell in the <tt>sst</tt> dataset, so use <tt>meshgrid</tt> to get the <tt>lat,lon</tt> arrays into 2D grids we'll call <tt>Lat,Lon</tt>:</p><pre class="codeinput">load <span class="string">pacific_sst.mat</span>

<span class="comment">% Get 2D grids from lat,lon arrays:</span>
[Lon,Lat] = meshgrid(lon,lat);
</pre><p>The simplest way to use the <tt>enso</tt> function is to enter the 3D <tt>sst</tt> data, the corresponding times <tt>t</tt>, and the grid cell coordinates, like this:</p><pre class="codeinput">idx = enso(sst,t,Lat,Lon);
</pre><h2 id="5">Plot it up real nice</h2><p>With that, we can now plot the Nino 3.4 anomalies. We'll use the <a href="anomaly_documentation.html"><tt>anomaly</tt></a> function with thresholds of +/- 0.4 degrees to identify El Nino and La Nina periods, respectively:</p><pre class="codeinput">figure
anomaly(t,idx,<span class="string">'thresh'</span>,[-0.4 0.4]);
axis <span class="string">tight</span>
hline(0,<span class="string">'k'</span>) <span class="comment">% places a horizontal line at 0</span>
datetick(<span class="string">'x'</span>,<span class="string">'keeplimits'</span>)
ylabel <span class="string">'Nino 3.4 SST anomaly (\circC)'</span>
</pre><img vspace="5" hspace="5" src="enso_documentation_01.png" alt=""> <h2 id="6">A bit of context</h2><p>For a bit more context, and to understand what the <tt>enso</tt> function is doing, here's the mean sea surface temperature from the pacific_sst dataset, plotted with <a href="imagescn_documentation.html"><tt>imagescn</tt></a> and using the <a href="cmocean_documentation.html"><tt>cmocean</tt></a> <i>thermal</i> colormap:</p><pre class="codeinput">figure
imagescn(Lon,Lat,mean(sst,3))
cmocean <span class="string">thermal</span>
</pre><img vspace="5" hspace="5" src="enso_documentation_02.png" alt=""> <p>By default the <tt>enso</tt> function calculates the the Nino index using the lat,lon bounds of the Nino 3.4 box (5N-5S; 170W-120W). Here's the Nino 3.4 region on a map:</p><pre class="codeinput"><span class="comment">% Define the Nino 3.4 box:</span>
latv = [-5 -5 5 5 -5];
lonv = [-170 -120 -120 -170 -170];

<span class="comment">% Plot the Nino 3.4 box:</span>
hold <span class="string">on</span>
plot(lonv,latv,<span class="string">'k-'</span>,<span class="string">'linewidth'</span>,2)
text(-170,5,<span class="string">'The Nino 3.4 box!'</span>,<span class="string">'vert'</span>,<span class="string">'bottom'</span>,<span class="string">'fontangle'</span>,<span class="string">'italic'</span>)
</pre><img vspace="5" hspace="5" src="enso_documentation_03.png" alt=""> <p>If you'd like to explore Nino indices in regions other than the default Nino 3.4 region, read on...</p><h2 id="9">Example 2: A manual approach</h2><p>By default, the <tt>enso</tt> function calculates the area-weighted average sea surface temperature within the Nino 3.4 box, then uses <a href="deseason_documentation.html"><tt>deseason</tt></a> to remove seasonal cycles. The the mean is removed from the deseasoned time series to get the ENSO anomalies, and then smoothed using <a href="scatstat1_documentation.html"><tt>scatstat1</tt></a> as a moving-average filter. The <tt>enso</tt> function allows you to override most of the steps of the Nino calculation or set them to your liking. Below are some examples of how to customize use of the <tt>enso</tt> function.</p><h2 id="10">Defining the Nino region</h2><p>To use one of the predefined Nino regions other than the default <tt>'3.4'</tt>, simply specify it like this:</p><pre class="codeinput">idx3 = enso(sst,t,Lat,Lon,<span class="string">'region'</span>,<span class="string">'3'</span>);
</pre><p>Loop through all the predefined Nino regions to compare:</p><pre class="codeinput"><span class="comment">% List the predefined regions:</span>
regions = {<span class="string">'1+2'</span>,<span class="string">'3'</span>,<span class="string">'3.4'</span>,<span class="string">'4'</span>,<span class="string">'ONI'</span>};

figure
hold <span class="string">on</span>

<span class="comment">% Loop through each region, calculate its Nino index, and plot:</span>
<span class="keyword">for</span> k = 1:length(regions)
   tmp = enso(sst,t,Lat,Lon,<span class="string">'region'</span>,regions{k});
   plot(t,tmp)
<span class="keyword">end</span>
axis <span class="string">tight</span>
datetick(<span class="string">'x'</span>,<span class="string">'keeplimits'</span>)
box <span class="string">off</span>
legend(regions)
</pre><img vspace="5" hspace="5" src="enso_documentation_04.png" alt=""> <p>Suppose you come up with a better region for characterizing El Nino and La Nina. It's the whole region from 20 S to 20 N, and from 170 W to 110 W, but only where grid cell latitudes and longitudes minus half a degree are divisible by 3. Use <a href="geomask_documentation.html"><tt>geomask</tt></a> to determine which grid cells lie within that region and use <tt>mod</tt> to figure out which grid cells (minus 0.5 degrees) are divisble by 3. Here's what the mask looks like:</p><pre class="codeinput">mask = geomask(Lat,Lon,[-20 20],[-170 -110]) <span class="keyword">...</span>
   &amp; mod(Lat-0.5,3)==0 &amp; mod(Lon-0.5,3)==0;

figure
imagescn(Lon,Lat,mask)
borders
</pre><img vspace="5" hspace="5" src="enso_documentation_05.png" alt=""> <p>If you'd like to get an <i>unweighted</i> Nino index for the region shown as yellow cells in the mask above, do this:</p><pre class="codeinput">idx = enso(sst,t,mask);

figure
anomaly(t,idx)
axis <span class="string">tight</span>
datetick(<span class="string">'x'</span>,<span class="string">'keepticks'</span>)
title <span class="string">'my fake Nino index'</span>
</pre><img vspace="5" hspace="5" src="enso_documentation_06.png" alt=""> <p>To account for the fact that the grid cells in your mask are not all equal in surface area on the globe use <a href="cdtarea_documentation.html"><tt>cdtarea</tt></a> to get the area of each grid cell, then use <a href="local_documentation.html"><tt>local</tt></a> to get the area-weighted time series of sea surface temperatures within your mask:</p><pre class="codeinput"><span class="comment">% Get the area of each grid cell:</span>
A = cdtarea(Lat,Lon);

<span class="comment">% Get the area-weighted time series in the Nino 3.4 box:</span>
sst_myregion = local(sst,mask,<span class="string">'weight'</span>,A);
</pre><p>Now <tt>sst_myregion</tt> is an 802x1 array of area-averaged sea surface temperatures in your mask, and and it can be entered directly into the <tt>enso</tt> function to convert it to an index:</p><pre class="codeinput">idx_myregion = enso(sst_myregion,t);
</pre><p>Plotting the area-weighted index on top of the unweighted anomaly plot, you will see that they are quite similar. Here's the weighted version plotted as a blue line on top of the anomaly plot we created above:</p><pre class="codeinput">hold <span class="string">on</span>
plot(t,idx_myregion,<span class="string">'b'</span>)
</pre><img vspace="5" hspace="5" src="enso_documentation_07.png" alt=""> <p>Whether or not we account for grid cell dimensions when calculating the mean sst within a mask, it doesn't seem to matter much here. That's because these grid cells are all within a relatively narrow range of latitudes close to the equator, where grid cells are all about the same size.</p><h2 id="18">Example 3: Recreating Trenberth 1997</h2><p>In this example, we'll recreate Figure 1 from Trenberth's 1997 classic paper, The Definition of El Nino (Trenberth, <a href="https://doi.org/10.1175/1520-0477(1997)078%3C2771:TDOENO%3E2.0.CO;2">1997</a>), which depicts the ENSO index calculated from Pacific sea surface temperatures.</p><p>We'll use the same pacific_sst dataset from the examples above. First, calculate the Nino 3 and Nino 3.4 indices:</p><pre class="codeinput">idx_3 = enso(sst,t,Lat,Lon,<span class="string">'region'</span>,<span class="string">'3'</span>);
idx_34 = enso(sst,t,Lat,Lon,<span class="string">'region'</span>,<span class="string">'3.4'</span>);
</pre><p>Now recreate both subplots of Trenberth's Figure 1, using <a href="subsubplot_documentation.html"><tt>subsubplot</tt></a>:</p><pre class="codeinput">figure
subsubplot(2,1,1)
anomaly(t,idx_3,<span class="string">'top'</span>,rgb(<span class="string">'charcoal'</span>),<span class="keyword">...</span>
   <span class="string">'bottom'</span>,rgb(<span class="string">'gray'</span>),<span class="string">'thresh'</span>,[-0.5 0.5]);

hline([-0.5 0.5],<span class="string">'k:'</span>)
hline(0,<span class="string">'k'</span>,<span class="string">'linewidth'</span>,1)

xlim(datenum([1950 1997.5],1,1))
ylim([-2 3])
ntitle(<span class="string">' Nino 3 Region (Threshold = 0.5\circC) '</span>,<span class="string">'location'</span>,<span class="string">'nw'</span>)

subsubplot(2,1,2)
anomaly(t,idx_34,<span class="string">'top'</span>,rgb(<span class="string">'charcoal'</span>),<span class="keyword">...</span>
   <span class="string">'bottom'</span>,rgb(<span class="string">'gray'</span>),<span class="string">'thresh'</span>,[-0.4 0.4]);

hline([-0.4 0.4],<span class="string">'k:'</span>)
hline(0,<span class="string">'k'</span>,<span class="string">'linewidth'</span>,1)

xlim(datenum([1950 1997.5],1,1))
ylim([-2 3])
ntitle(<span class="string">' Nino 3.4 Region (Threshold = 0.4\circC) '</span>,<span class="string">'location'</span>,<span class="string">'nw'</span>)

datetick(<span class="string">'x'</span>,<span class="string">'keeplimits'</span>)
xlabel(<span class="string">'Year'</span>)
</pre><img vspace="5" hspace="5" src="enso_documentation_08.png" alt=""> <h2 id="20">References</h2><p>Trenberth, Kevin E. "The Definition of El Nino." Bulletin of the American Meteorological Society 78.12 (1997): 2771-2778. <a href="https://doi.org/10.1175/1520-0477(1997)078%3C2771:TDOENO%3E2.0.CO;2">https://doi.org/10.1175/1520-0477(1997)078%3C2771:TDOENO%3E2.0.CO;2</a></p><h2 id="21">Author Info</h2><p>The <tt>enso</tt> function and supporting documentation were written by <a href="Kaustubh">Thirumalai &lt;http://www.kaustubh.info</a>&gt; and <a href="http://www.chadagreene.com">Chad A. Greene</a> for the Climate Data Toolbox for Matlab, 2019.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% |enso| documentation 
% |enso| computes a version of the Nino 3.4 SST index.  
%
% <CDT_Contents.html Back to Climate Data Tools Contents>
%% Syntax 
% 
%  idx = enso(sst,t) 
%  idx = enso(sst,t,lat,lon)
%  idx = enso(sst,t,lat,lon,'region',NinoRegion)
%  idx = enso(sst,t,mask)
%  idx = enso(...,'smoothing',months)   
% 
%% Description 
% 
% |idx = enso(sst,t)| calculates El Nino Southern Oscillation index from 
% a time series of sea surface temperatures sst and their corresponding 
% times |t|. sst can be a vector of sea surface temperatures that have been
% averaged over a region of interest, or sst can be a 3D matrix whose third
% dimension correponds to times |t|. If sst is a 3D matrix, a time series is
% automatically generated by averaging all the grid cells in sst for each
% time step. 
% 
% |idx = enso(sst,t,lat,lon)| calculates the Nino 3.4 index for 3D |sst| time
% series and corresponding grid coordinates |lat,lon|. Using this syntax,
% grid cells within the Nino 3.4 region are automatically determined and
% the Nino index is calculated from the area-averaged time series of ssts
% within that region. 
% 
% |idx = enso(sst,t,lat,lon,'region',NinoRegion)| allows any of the following
% Nino regions, entered as string (in 'single quotes') 
% 
% * |'1+2'|
% * |'3'|
% * |'3.4'| (default when lat and lon are specified)
% * |'4'|
% * |'ONI'| 
% 
% |idx = enso(sst,t,mask)| calculates the sst index using the unweighted mean
% of sst grid cells corresponding to true values in a 2D logical |mask|. 
% 
% |idx = enso(...,'smoothing',months)| defines the moving average window
% in months. Default value is |5|, following Trenberth 1997. The only exception
% is for the ONI region, which has a smoothing window of |3| months. To turn off
% averaging, set |'smoothing',false|. 
% 
%% Example 1: Automatic Nino 3.4
% For this example, calculate the Nino 3.4 index using the monthly
% pacific_sst.mat dataset that comes with CDT. Start by loading the data, and
% then the |enso| function will want to know exactly what geo coordinates correspond
% to each grid cell in the |sst| dataset, so use |meshgrid| to get the |lat,lon|
% arrays into 2D grids we'll call |Lat,Lon|: 

load pacific_sst.mat

% Get 2D grids from lat,lon arrays: 
[Lon,Lat] = meshgrid(lon,lat);

%% 
% The simplest way to use the |enso| function is to enter the 3D |sst| data, 
% the corresponding times |t|, and the grid cell coordinates, like this: 

idx = enso(sst,t,Lat,Lon); 

%% Plot it up real nice
% With that, we can now plot the Nino 3.4 anomalies. We'll use the
% <anomaly_documentation.html |anomaly|> function with thresholds of +/-
% 0.4 degrees to identify El Nino and La Nina periods, respectively: 

figure
anomaly(t,idx,'thresh',[-0.4 0.4]); 
axis tight
hline(0,'k') % places a horizontal line at 0
datetick('x','keeplimits')
ylabel 'Nino 3.4 SST anomaly (\circC)'

%% A bit of context
% For a bit more context, and to understand what the |enso| function is doing, 
% here's the mean sea surface temperature from the pacific_sst dataset,
% plotted with <imagescn_documentation.html |imagescn|> and using the <cmocean_documentation.html 
% |cmocean|> _thermal_ colormap: 

figure
imagescn(Lon,Lat,mean(sst,3))
cmocean thermal 

%%
% By default the |enso| function calculates the the Nino index using
% the lat,lon bounds of the Nino 3.4 box (5N-5S; 170W-120W). Here's the
% Nino 3.4 region on a map: 

% Define the Nino 3.4 box: 
latv = [-5 -5 5 5 -5]; 
lonv = [-170 -120 -120 -170 -170]; 

% Plot the Nino 3.4 box: 
hold on
plot(lonv,latv,'k-','linewidth',2)
text(-170,5,'The Nino 3.4 box!','vert','bottom','fontangle','italic')

%% 
% If you'd like to explore Nino indices in regions other than the default
% Nino 3.4 region, read on...

%% Example 2: A manual approach
% By default, the |enso| function calculates the area-weighted average sea 
% surface temperature within the Nino 3.4 box, then uses <deseason_documentation.html |deseason|>
% to remove seasonal cycles. The the mean is removed from the deseasoned
% time series to get the ENSO anomalies, and then smoothed using
% <scatstat1_documentation.html |scatstat1|> as a moving-average filter.
% The |enso| function allows you to override most of the steps of the Nino
% calculation or set them to your liking. Below are some examples of how to
% customize use of the |enso| function. 
%
%% Defining the Nino region
% To use one of the predefined Nino regions other than the default |'3.4'|,
% simply specify it like this: 

idx3 = enso(sst,t,Lat,Lon,'region','3'); 

%% 
% Loop through all the predefined Nino regions to compare: 

% List the predefined regions: 
regions = {'1+2','3','3.4','4','ONI'}; 

figure
hold on

% Loop through each region, calculate its Nino index, and plot: 
for k = 1:length(regions)
   tmp = enso(sst,t,Lat,Lon,'region',regions{k});
   plot(t,tmp)
end
axis tight
datetick('x','keeplimits') 
box off 
legend(regions)

%% 
% Suppose you come up with a better region for characterizing El Nino and
% La Nina. It's the whole region from 20 S to 20 N, and from 170 W to 110 W, but 
% only where grid cell latitudes and longitudes minus half a degree are
% divisible by 3. Use <geomask_documentation.html |geomask|> to determine which grid 
% cells lie within that region and use |mod| to figure out which grid cells
% (minus 0.5 degrees) are divisble by 3. Here's what the mask looks like: 

mask = geomask(Lat,Lon,[-20 20],[-170 -110]) ...
   & mod(Lat-0.5,3)==0 & mod(Lon-0.5,3)==0; 

figure
imagescn(Lon,Lat,mask) 
borders

%% 
% If you'd like to get an _unweighted_ Nino index for the region shown as
% yellow cells in the mask above, do this: 

idx = enso(sst,t,mask); 

figure
anomaly(t,idx)
axis tight
datetick('x','keepticks') 
title 'my fake Nino index' 

%% 
% To account for the fact that the grid cells in your mask are not all
% equal in surface area on the globe use <cdtarea_documentation.html |cdtarea|> to get the area of each 
% grid cell, then use <local_documentation.html |local|> to get the area-weighted 
% time series of sea surface temperatures within your mask: 

% Get the area of each grid cell: 
A = cdtarea(Lat,Lon); 

% Get the area-weighted time series in the Nino 3.4 box: 
sst_myregion = local(sst,mask,'weight',A); 

%%
% Now |sst_myregion| is an 802x1 array of area-averaged sea surface
% temperatures in your mask, and and it can be entered directly into the
% |enso| function to convert it to an index: 

idx_myregion = enso(sst_myregion,t); 

%% 
% Plotting the area-weighted index on top of the unweighted anomaly plot,
% you will see that they are quite similar. Here's the weighted version
% plotted as a blue line on top of the anomaly plot we created above: 

hold on
plot(t,idx_myregion,'b') 

%% 
% Whether or not we account for grid cell dimensions when calculating the
% mean sst within a mask, it doesn't seem to matter much here. That's
% because these grid cells are all within a relatively narrow range of
% latitudes close to the equator, where grid cells are all about the same
% size. 

%% Example 3: Recreating Trenberth 1997
% In this example, we'll recreate Figure 1 from Trenberth's 1997 classic paper, 
% The Definition of El Nino (Trenberth, <https://doi.org/10.1175/1520-0477(1997)078%3C2771:TDOENO%3E2.0.CO;2 
% 1997>), which depicts the ENSO index calculated from Pacific sea surface temperatures. 
% 
% We'll use the same pacific_sst dataset from the examples above. First,
% calculate the Nino 3 and Nino 3.4 indices: 

idx_3 = enso(sst,t,Lat,Lon,'region','3'); 
idx_34 = enso(sst,t,Lat,Lon,'region','3.4'); 

%% 
% Now recreate both subplots of Trenberth's Figure 1, using <subsubplot_documentation.html
% |subsubplot|>: 

figure
subsubplot(2,1,1) 
anomaly(t,idx_3,'top',rgb('charcoal'),...
   'bottom',rgb('gray'),'thresh',[-0.5 0.5]);

hline([-0.5 0.5],'k:')
hline(0,'k','linewidth',1)

xlim(datenum([1950 1997.5],1,1))
ylim([-2 3])
ntitle(' Nino 3 Region (Threshold = 0.5\circC) ','location','nw')

subsubplot(2,1,2) 
anomaly(t,idx_34,'top',rgb('charcoal'),...
   'bottom',rgb('gray'),'thresh',[-0.4 0.4]);

hline([-0.4 0.4],'k:')
hline(0,'k','linewidth',1)

xlim(datenum([1950 1997.5],1,1))
ylim([-2 3])
ntitle(' Nino 3.4 Region (Threshold = 0.4\circC) ','location','nw')

datetick('x','keeplimits') 
xlabel('Year')

%% References 
% 
% Trenberth, Kevin E. "The Definition of El Nino." Bulletin of the American Meteorological
% Society 78.12 (1997): 2771-2778. <https://doi.org/10.1175/1520-0477(1997)078%3C2771:TDOENO%3E2.0.CO;2>

%% Author Info
% The |enso| function and supporting documentation were written by <Kaustubh Thirumalai http://www.kaustubh.info> 
% and <http://www.chadagreene.com Chad A. Greene> for the Climate Data Toolbox for Matlab, 2019.  

##### SOURCE END #####
--></body></html>